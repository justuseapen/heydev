# HeyDev Progress Log

Branch: ralph/heydev-feedback-widget

## Stories

| ID | Title | Status |
|----|-------|--------|
| US-001 | Project setup with TypeScript and build tooling | complete |
| US-002 | Database schema for API keys and channels | complete |
| US-003 | Backend server setup with Hono | complete |
| US-004 | API key validation middleware | complete |
| US-005 | File upload endpoint for screenshots | complete |
| US-006 | Transcription endpoint with Whisper fallback | complete |
| US-007 | Feedback submission endpoint | complete |
| US-008 | Context capture utility module | complete |
| US-009 | Console error capture utility | complete |
| US-010 | Session ID generation and storage | complete |
| US-011 | Widget floating button component | complete |
| US-012 | Widget feedback panel skeleton | complete |
| US-013 | Text input in feedback panel | complete |
| US-014 | Screenshot capture button | complete |
| US-015 | Voice recording button with Web Speech API | complete |
| US-016 | Voice recording fallback to Whisper API | complete |
| US-017 | Submit feedback to backend | complete |
| US-018 | Widget script entry point and initialization | complete |
| US-019 | Widget Vite build configuration | complete |
| US-020 | Notification channel router | complete |
| US-021 | Webhook notification sender | complete |
| US-022 | Webhook retry logic | complete |
| US-023 | Webhook reply endpoint | complete |
| US-024 | SSE endpoint for real-time replies | complete |
| US-025 | Widget SSE connection for replies | complete |
| US-026 | Conversation history in widget | complete |
| US-027 | User follow-up replies | complete |
| US-028 | Dashboard project setup | complete |
| US-029 | Dashboard magic link authentication | complete |
| US-030 | Dashboard API key generation | complete |
| US-031 | Dashboard notification channel list | complete |
| US-032 | Dashboard webhook channel configuration | complete |
| US-033 | Dashboard email channel configuration | complete |
| US-034 | Email notification sender | complete |
| US-035 | Docker Compose for self-hosting | complete |
| US-036 | Widget dark mode support | complete |
| US-037 | Widget accessibility | complete |

---

## Codebase Patterns
- Use npm workspaces for monorepo structure (widget, server, dashboard)
- Widget components in widget/src/components/ with createXxx() factory pattern
- Use `tsc -b` for TypeScript builds with project references
- ESLint 9 flat config with typescript-eslint plugin
- All workspaces extend root tsconfig.json with composite: true
- Drizzle ORM for database with better-sqlite3 driver
- drizzle-orm installed at root level for drizzle-kit compatibility
- Database stored in server/data/heydev.db (gitignored, created at runtime)
- Hono server with @hono/node-server adapter for HTTP endpoints
- CORS enabled by default allowing all origins
- Use `createMiddleware` from `hono/factory` for typed custom middleware
- Extend `ContextVariableMap` in `declare module 'hono'` for custom context variables
- Protected routes pattern: create new Hono instance, apply middleware, mount with `app.route('/api', api)`
- Widget build: Vite library mode with IIFE format, `npm run build` in widget/ outputs dist/widget.js
- Heavy dependencies (html2canvas): load from CDN at runtime to keep bundle small
- Dashboard: React + TailwindCSS + React Router, functional components, runs on port 5174

---

## Iteration Log

## 2026-01-12 - US-001
- What was implemented:
  - Initialized npm monorepo with workspaces for widget, server, dashboard
  - Configured TypeScript 5.4 with strict mode and project references
  - Set up ESLint 9 with typescript-eslint flat config
  - Added Prettier with sensible defaults
  - Created placeholder entry points for each workspace
- Files changed:
  - package.json (root)
  - tsconfig.json (root + 3 workspaces)
  - eslint.config.js
  - .prettierrc, .prettierignore, .gitignore
  - widget/package.json, server/package.json, dashboard/package.json
  - widget/src/index.ts, server/src/index.ts, dashboard/src/index.tsx
- **Learnings for future iterations:**
  - Root tsconfig.json uses `files: []` with `references` array for project references
  - Each workspace needs `composite: true` in its tsconfig
  - Use `tsc -b` (build mode) instead of `tsc --noEmit` for project references
  - ESLint 9 requires flat config format, not .eslintrc

---

## 2026-01-12 - US-002
- What was implemented:
  - SQLite database with Drizzle ORM (better-sqlite3)
  - api_keys table (id, key, created_at, user_id)
  - channels table with type enum (slack/email/sms/webhook), config JSON, enabled/verified boolean
  - conversations table (id, api_key_id, session_id, created_at)
  - messages table with direction enum (inbound/outbound)
  - Drizzle Kit configuration for migrations (drizzle.config.js)
  - Migration scripts: db:generate, db:migrate, db:push, db:studio
- Files changed:
  - server/src/db/schema.ts (schema definitions with TypeScript types)
  - server/src/db/index.ts (database connection with auto-directory creation)
  - server/drizzle.config.js (Drizzle Kit config)
  - server/drizzle/0000_abandoned_proteus.sql (initial migration)
  - server/package.json (added drizzle dependencies and scripts)
  - .gitignore (added server/data/ for SQLite database)
- **Learnings for future iterations:**
  - drizzle-orm must be installed at root level in npm workspaces for drizzle-kit to work
  - Use drizzle.config.js (JS) instead of .ts for simpler config loading
  - SQLite uses `text` columns with `enum` option for enum-like behavior
  - Use `$defaultFn` for dynamic defaults like `new Date().toISOString()`
  - Database directory is created at runtime (server/data/) - not checked into git

---

## 2026-01-12 - US-003
- What was implemented:
  - Hono server configured in /server with Node.js adapter
  - CORS middleware allowing all origins via `cors()` middleware
  - Health check endpoint GET /health returns {status: 'ok'}
  - Server runs on configurable port via PORT env var (default 3000)
- Files changed:
  - server/src/index.ts (Hono server setup with CORS and health endpoint)
  - server/package.json (added hono and @hono/node-server dependencies)
  - package-lock.json (updated with new dependencies)
- **Learnings for future iterations:**
  - Use `@hono/node-server` adapter for running Hono in Node.js
  - Hono's `cors()` middleware from `hono/cors` allows all origins by default
  - Export the `app` instance for use by other modules (middleware, routes)

---

## 2026-01-12 - US-004
- What was implemented:
  - API key validation middleware using Hono's createMiddleware
  - Extracts API key from X-API-Key header or api_key query parameter
  - Validates key against database using Drizzle ORM eq() query
  - Returns 401 with error message if missing or invalid
  - Attaches full ApiKey record to Hono context via c.set('apiKey', record)
  - TypeScript module augmentation for typed context access
  - Protected route pattern: separate Hono instance mounted under /api
  - Example /api/me endpoint demonstrating middleware usage
- Files changed:
  - server/src/middleware/apiKey.ts (new middleware file)
  - server/src/index.ts (imported middleware, created protected API routes)
- **Learnings for future iterations:**
  - Use `createMiddleware` from `hono/factory` for typed middleware with Next function
  - Must `return next()` (not `await next()`) to satisfy TypeScript return type
  - Use `declare module 'hono'` with `ContextVariableMap` interface for typed context
  - Drizzle query syntax: `db.query.tableName.findFirst({ where: eq(table.column, value) })`
  - Pattern for protected routes: create sub-Hono, apply middleware with `use('*')`, mount with `route()`

---

## 2026-01-12 - US-005
- What was implemented:
  - File upload endpoint POST /api/upload accepting multipart/form-data
  - Image validation for png, jpg, webp file types
  - Image resizing to max 1200px width using sharp library
  - Files stored in /uploads directory with UUID-based filenames
  - JSON response with url field pointing to uploaded file
  - Static file serving at GET /uploads/:filename using serveStatic
- Files changed:
  - server/src/routes/upload.ts (new upload route handler)
  - server/src/index.ts (added upload routes and static serving)
  - server/package.json (added sharp and uuid dependencies)
  - package-lock.json (updated with new dependencies)
- **Learnings for future iterations:**
  - Use `sharp` library for image processing in Node.js (automatic format detection, resizing)
  - Use `@hono/node-server/serve-static` for serving static files with `root: './'` to serve from cwd
  - Hono FormData: use `c.req.formData()` and check `file instanceof File`
  - File.arrayBuffer() returns ArrayBuffer, convert to Buffer with `Buffer.from(arrayBuffer)`
  - Uploads directory is created at runtime if it doesn't exist
  - Pattern for sub-routes: create new Hono instance, export it, mount with `api.route('/path', routes)`

---

## 2026-01-12 - US-006
- What was implemented:
  - POST /api/transcribe endpoint accepting audio blob (webm/opus and other formats)
  - OpenAI Whisper API integration for server-side transcription
  - In-memory rate limiting (10 requests/minute per session)
  - Proper error handling for OpenAI API errors (401, 429, etc.)
  - Periodic cleanup of old rate limit entries to prevent memory leaks
- Files changed:
  - server/src/routes/transcribe.ts (new transcription route handler)
  - server/src/index.ts (imported and mounted transcribe routes)
  - server/package.json (added openai dependency)
  - package-lock.json (updated with new dependencies)
- **Learnings for future iterations:**
  - OpenAI SDK v4+ accepts native Fetch API File objects directly for audio upload
  - Use `openai.audio.transcriptions.create()` with `model: 'whisper-1'`
  - OpenAI SDK reads `OPENAI_API_KEY` environment variable automatically
  - Check `error instanceof OpenAI.APIError` for typed error handling
  - Simple in-memory rate limiting with Map works for single-instance servers
  - Pattern for rate limiting: track windowStart timestamp and count per session

---

## 2026-01-12 - US-007
- What was implemented:
  - POST /api/feedback endpoint accepting JSON with text, screenshot_url, audio_url, context object
  - Context validation for required fields (url, browser, os, viewport, timestamp, timezone)
  - Creates or retrieves conversation by session_id (using apiKeyId + sessionId compound lookup)
  - Stores message in messages table with direction 'inbound'
  - Message content stored as JSON string including text, screenshot_url, audio_url, and full context
  - Returns JSON with conversation_id
- Files changed:
  - server/src/routes/feedback.ts (new feedback route handler)
  - server/src/index.ts (imported and mounted feedback routes)
- **Learnings for future iterations:**
  - Use `and()` from drizzle-orm for compound WHERE clauses: `and(eq(col1, val1), eq(col2, val2))`
  - Drizzle's `.returning()` method returns array of inserted records
  - Pattern for "find or create": first query with findFirst, then insert if null
  - Store structured data as JSON string in content field for flexibility

---

## 2026-01-12 - US-008
- What was implemented:
  - Context capture utility module in widget/src/utils/context.ts
  - captureContext() function returns PageContext object
  - Browser parsing from userAgent (Edge, Opera, Chrome, Safari, Firefox)
  - OS parsing from userAgent (iOS, Android, Windows, macOS, Linux, Chrome OS)
  - Viewport captured from window.innerWidth/innerHeight
  - Timestamp in ISO 8601 format using new Date().toISOString()
  - Timezone name from Intl.DateTimeFormat().resolvedOptions().timeZone
- Files changed:
  - widget/src/utils/context.ts (new context capture module)
  - widget/src/index.ts (exported captureContext and PageContext type)
- **Learnings for future iterations:**
  - Widget utilities go in widget/src/utils/ directory
  - Export types with `export { type TypeName }` syntax for type-only exports
  - Browser detection order matters: check specific variants (Edge) before generic (Chrome)
  - Intl.DateTimeFormat().resolvedOptions().timeZone gives the timezone name (e.g., "America/New_York")

---

## 2026-01-12 - US-009
- What was implemented:
  - Console error capture utility in widget/src/utils/consoleErrors.ts
  - installErrorInterceptor() function to replace console.error with interceptor
  - uninstallErrorInterceptor() to restore original behavior
  - getConsoleErrors() returns array of captured errors (up to 5, within last 5 minutes)
  - clearCapturedErrors() for testing/reset
  - Errors stored with message and ISO timestamp
  - Old errors (>5 minutes) pruned automatically on capture or retrieval
  - Original console.error behavior preserved (calls original after capturing)
- Files changed:
  - widget/src/utils/consoleErrors.ts (new console error capture module)
  - widget/src/index.ts (exported new functions and CapturedError type)
  - server/src/routes/feedback.ts (fixed lint error - Array<T> to T[])
- **Learnings for future iterations:**
  - Intercept browser APIs by storing original, replacing with wrapper, calling original inside wrapper
  - Use `Function.apply(console, args)` to preserve proper `this` context when calling original
  - Store interceptor installation state to prevent double-installation
  - Pruning strategy: prune on both capture and retrieval to keep memory bounded

---

## 2026-01-12 - US-010
- What was implemented:
  - Session ID generation and storage utility in widget/src/utils/session.ts
  - getSessionId() function returns existing or creates new session ID
  - Session ID stored in sessionStorage (not cookies) for browser session persistence
  - Session ID format: 'sess_' + 16 random alphanumeric chars
  - Uses crypto.getRandomValues() for secure random generation
  - clearSessionId() function for testing/logout scenarios
  - In-memory fallback when sessionStorage is unavailable
- Files changed:
  - widget/src/utils/session.ts (new session ID module)
  - widget/src/index.ts (exported getSessionId and clearSessionId)
- **Learnings for future iterations:**
  - Use crypto.getRandomValues() for secure random generation in browsers
  - sessionStorage persists only for the browser session (tab/window lifetime)
  - Always provide fallback when browser APIs might be unavailable (private mode, etc.)
  - Test sessionStorage availability with try/catch around actual set/get operations

---


## 2026-01-12 - US-011
- What was implemented:
  - Floating feedback button component in widget/src/components/FloatingButton.ts
  - Circular 56px button fixed to bottom-right corner (24px from edges)
  - Chat/feedback SVG icon inline
  - Subtle box-shadow with hover state (scale 1.05)
  - Entrance animation (fade + slide up from 16px)
  - Dispatches 'heydev:open' custom event on click
  - CSS custom properties for theming (--heydev-primary defaults to #6366f1)
  - ARIA label for accessibility
  - Respects prefers-reduced-motion media query
  - Test page with Vite dev server for browser verification
- Files changed:
  - widget/src/components/FloatingButton.ts (new component)
  - widget/src/index.ts (exported new component)
  - widget/index.html (test page for development)
  - widget/vite.config.ts (Vite config for dev server)
- **Learnings for future iterations:**
  - Widget components go in widget/src/components/ directory
  - Use createXxx() factory function pattern returning instance with control methods
  - Inject styles dynamically with unique ID to prevent duplicates
  - Use CSS custom properties (--heydev-*) for theming
  - Always include ARIA labels for accessibility
  - Test with `npm run dev` in widget/ directory at http://localhost:5173/
  - Custom events need `bubbles: true, composed: true` for Shadow DOM compatibility

---

## 2026-01-12 - US-012
- What was implemented:
  - Feedback panel component in widget/src/components/FeedbackPanel.ts
  - Panel 360px wide, 480px max height, positioned 96px from bottom (above button)
  - Header with 'Send Feedback' title and close (X) button with hover states
  - Slide-up animation on open, slide-down animation on close (opacity + translateY)
  - Overlay element for click-outside-to-close functionality
  - Opens on 'heydev:open' event, closes on 'heydev:close' event or X click
  - Escape key closes panel
  - CSS custom properties for theming (--heydev-panel-bg, --heydev-border, etc.)
  - ARIA attributes for accessibility (role="dialog", aria-label, aria-modal)
  - Respects prefers-reduced-motion media query
- Files changed:
  - widget/src/components/FeedbackPanel.ts (new component)
  - widget/src/index.ts (exported new component)
  - widget/index.html (updated test page to include panel)
- **Learnings for future iterations:**
  - Use overlay element (position: fixed, inset: 0) for click-outside detection
  - Panel uses pointer-events: none when closed, pointer-events: auto when open
  - Focus close button after panel opens for accessibility
  - Panel components expose body element for adding content in future stories

---

## 2026-01-12 - US-013
- What was implemented:
  - Text input component in widget/src/components/TextInput.ts
  - Textarea with placeholder "What's on your mind?"
  - Auto-resizing textarea up to 150px max height using scrollHeight
  - Submit button with send icon, disabled when textarea is empty
  - Cmd/Ctrl+Enter keyboard shortcut to submit
  - CSS custom properties for theming (--heydev-input-bg, --heydev-primary-hover)
  - ARIA labels for accessibility
  - Respects prefers-reduced-motion media query
- Files changed:
  - widget/src/components/TextInput.ts (new component)
  - widget/src/index.ts (exported new component)
  - widget/index.html (updated test page to integrate TextInput into panel)
- **Learnings for future iterations:**
  - Auto-resize textarea: set height to 'auto', then set to scrollHeight (capped at max)
  - Use box-sizing: border-box on textarea to include padding in width calculation
  - Keyboard shortcuts: listen for `metaKey` (Mac Cmd) or `ctrlKey` (Windows/Linux Ctrl)
  - Components receive onSubmit callback in options for parent to handle submission
  - TextInput exposes getValue(), setValue(), clear(), focus() for programmatic control

---

## 2026-01-12 - US-014
- What was implemented:
  - Screenshot capture button component in widget/src/components/ScreenshotButton.ts
  - Camera icon button displayed next to textarea in feedback panel
  - Uses html2canvas library to capture visible viewport
  - Loading spinner animation while capturing (rotating icon)
  - 80px thumbnail preview displayed below text area after capture
  - Red X button on thumbnail to remove screenshot
  - Only one screenshot allowed at a time (button disabled after capture)
  - CSS custom properties for theming (--heydev-btn-secondary-bg, --heydev-danger, etc.)
  - ARIA labels for accessibility
  - Respects prefers-reduced-motion media query
- Files changed:
  - widget/src/components/ScreenshotButton.ts (new component)
  - widget/src/index.ts (exported new component)
  - widget/index.html (updated test page to integrate ScreenshotButton)
  - widget/package.json (added html2canvas dependency)
  - package-lock.json (updated with new dependencies)
- **Learnings for future iterations:**
  - html2canvas options: use scale:1, useCORS:true, logging:false for viewport capture
  - Capture viewport with x:scrollX, y:scrollY, width:innerWidth, height:innerHeight
  - ScreenshotButton exposes hasScreenshot(), getScreenshot(), clearScreenshot() for integration
  - Use separate container and previewContainer options to place preview in different location
  - onCapture callback receives data URL, onRemove callback for cleanup

---

## 2026-01-12 - US-015
- What was implemented:
  - Voice recording button component in widget/src/components/VoiceButton.ts
  - Microphone button prominently displayed next to screenshot button in feedback panel
  - Uses Web Speech API (SpeechRecognition) for real-time transcription
  - Visual indicator (pulsing red dot) when recording via CSS animation
  - Transcribed text updates textarea in real-time as user speaks
  - Toggle recording by clicking button again
  - 60-second maximum recording duration with automatic stop
  - Shows 'Voice not supported' message if browser lacks Web Speech API
  - Full TypeScript type definitions for SpeechRecognition API
  - CSS custom properties for theming (--heydev-danger, --heydev-btn-secondary-bg)
  - ARIA labels for accessibility
  - Respects prefers-reduced-motion media query
- Files changed:
  - widget/src/components/VoiceButton.ts (new voice button component)
  - widget/src/index.ts (exported new component and types)
  - widget/index.html (integrated voice button into test page)
- **Learnings for future iterations:**
  - Web Speech API types not built into TypeScript - need custom interface declarations
  - Use `type = new () => T` syntax instead of interface with call signature for constructors (ESLint rule)
  - SpeechRecognition accessed via window.SpeechRecognition or window.webkitSpeechRecognition
  - recognition.continuous = true for continuous listening, interimResults = true for real-time feedback
  - recognition.onresult event has resultIndex and results array with isFinal flag per result
  - VoiceButton exposes isSupported(), isRecording(), startRecording(), stopRecording(), toggleRecording()
  - Headless browsers (Playwright Chromium) don't support Web Speech API - test in real browser for full functionality

---

## 2026-01-12 - US-016
- What was implemented:
  - MediaRecorder + Whisper API fallback when Web Speech API is unavailable
  - isMediaRecorderSupported() check for fallback availability
  - Uses navigator.mediaDevices.getUserMedia() to capture audio
  - MediaRecorder captures audio in webm/opus format (with fallback to webm or mp4)
  - Audio chunks collected and uploaded to /api/transcribe endpoint on stop
  - Loading spinner with spinning animation during transcription
  - New CSS class .is-transcribing with primary color background
  - New options: transcribeEndpoint, getSessionId, onTranscribingStart, onTranscribingEnd
  - New instance methods: isFallbackMode(), isTranscribing()
  - Test page updated with fallback configuration
- Files changed:
  - widget/src/components/VoiceButton.ts (extended with fallback mode)
  - widget/index.html (added transcribeEndpoint and getSessionId options)
- **Learnings for future iterations:**
  - MediaRecorder.isTypeSupported() to detect best audio format
  - navigator.mediaDevices.getUserMedia() returns Promise, needs async handling
  - MediaRecorder.ondataavailable fires when data is ready (use start(timeslice) for periodic events)
  - MediaRecorder.onstop is async-friendly - can await transcription inside
  - DOMException with name 'NotAllowedError' indicates microphone access denied
  - Must stop MediaStream tracks to release microphone after recording
  - Two-mode pattern: check native support first, then fallback support, then unsupported

---

## 2026-01-12 - US-017
- What was implemented:
  - submitFeedback service in widget/src/services/submitFeedback.ts
  - Handles complete submission flow: context capture, screenshot upload, feedback POST
  - FeedbackForm component in widget/src/components/FeedbackForm.ts
  - Integrates TextInput, ScreenshotButton, VoiceButton into cohesive form
  - Loading spinner on submit button during submission
  - Success message ("Feedback sent!") with auto-close after 2 seconds
  - Error handling with user-friendly error display
  - Context capture includes console errors captured by error interceptor
  - Lazy OpenAI client initialization to prevent server crash without API key
  - Updated test page to use new FeedbackForm component with config inputs
- Files changed:
  - widget/src/services/submitFeedback.ts (new submission service)
  - widget/src/components/FeedbackForm.ts (new integrated form component)
  - widget/src/index.ts (exported new components and services)
  - widget/index.html (updated to use FeedbackForm with endpoint/apiKey config)
  - server/src/routes/transcribe.ts (lazy OpenAI initialization)
- **Learnings for future iterations:**
  - Use services directory for API-related functionality (widget/src/services/)
  - dataUrlToBlob() converts base64 data URLs to Blob for FormData upload
  - Lazy initialization pattern: check env var at runtime instead of module load time
  - Form components should receive endpoint/apiKey config for flexibility
  - CSS class toggling pattern: submitBtn.classList.add('is-loading') for loading states
  - Test API keys can be created with scripts/add-test-key.js using tsx

---

## 2026-01-12 - US-018
- What was implemented:
  - Widget script entry point in widget/src/widget.ts
  - Auto-initialization from script tag with data-api-key attribute
  - Optional data-endpoint attribute for custom backend URL (default: https://api.heydev.io)
  - Shadow DOM container for complete style isolation from host page
  - Floating button and feedback panel rendered inside shadow root
  - Public window.HeyDev API with open(), close(), isOpen(), destroy() methods
  - Test page widget-test.html demonstrating script tag usage
- Files changed:
  - widget/src/widget.ts (widget entry point)
  - widget/widget-test.html (test page for script tag integration)
- **Learnings for future iterations:**
  - Shadow DOM creates isolated style boundary - use attachShadow({ mode: 'open' })
  - Style reset with `:host { all: initial; }` prevents host page styles leaking in
  - Events need `composed: true` to cross shadow DOM boundary
  - Use `document.querySelectorAll('script[data-api-key]')` to find widget script tag
  - Listen for heydev:open event on shadow container, not document, for Shadow DOM events
  - Test widget initialization with setTimeout in test pages (widget loads async)

---

## 2026-01-12 - US-019
- What was implemented:
  - Vite library mode configuration for widget bundling
  - Single widget.js output file (33KB raw, 9.5KB gzipped) with CSS inlined
  - IIFE format for direct script tag inclusion
  - Source maps generated for debugging (widget.js.map)
  - html2canvas loaded from CDN at runtime to reduce bundle size
  - Added unpkg/jsdelivr fields to package.json for CDN distribution
- Files changed:
  - widget/vite.config.ts (library mode configuration with IIFE output)
  - widget/package.json (moved html2canvas to devDeps, added CDN fields)
  - widget/src/components/ScreenshotButton.ts (dynamic CDN loading for html2canvas)
  - package-lock.json (updated dependencies)
- **Learnings for future iterations:**
  - Use `build.lib` for library mode output with `formats: ['iife']` for script tag usage
  - Use `external` to exclude heavy dependencies and load from CDN at runtime
  - Dynamic script loading pattern: create script element, set src, listen for onload/onerror
  - `esbuild` minifier is built into Vite - no need to install `terser` separately
  - Bundle size optimization: CDN loading of optional dependencies keeps core bundle small
  - IIFE format wraps bundle as `var HeyDev=function(A){...}({})` for global scope exposure

---

## 2026-01-12 - US-020
- What was implemented:
  - Notification channel router service in server/src/services/channelRouter.ts
  - routeToChannels() function fetches all enabled channels for an API key
  - Channel sender registry for pluggable sender implementations per channel type
  - Concurrent channel delivery using Promise.all()
  - DeliverySummary response with totalChannels, successful, failed counts
  - ChannelResult type for individual channel delivery status
  - Helper functions: registerChannelSender(), hasSender(), getRegisteredChannelTypes()
  - Fixed pre-existing lint errors in widget code
- Files changed:
  - server/src/services/channelRouter.ts (new channel router service)
  - widget/src/components/ScreenshotButton.ts (lint fix: import type at module level)
  - widget/src/widget.ts (lint fix: use const instead of let)
- **Learnings for future iterations:**
  - Server services go in server/src/services/ directory
  - Use registry pattern for extensible sender functions per channel type
  - Drizzle query for multiple rows: `db.query.tableName.findMany({ where: ... })`
  - Promise.all() for concurrent async operations with error handling per item
  - ESLint rule @typescript-eslint/consistent-type-imports forbids inline `typeof import('x')` - use module-level import type instead

---

## 2026-01-12 - US-021
- What was implemented:
  - Webhook notification sender in server/src/services/webhookSender.ts
  - POST request to configured webhook URL with documented payload schema
  - Payload structure: { event: 'feedback.received', feedback, context, session_id, timestamp }
  - HMAC-SHA256 signature in X-HeyDev-Signature header when secret is configured
  - Custom headers from channel.config.headers merged into request
  - 5 second timeout using AbortController
  - Returns ChannelResult with success/failure and statusCode
  - Registered webhook sender in server entry point for automatic initialization
- Files changed:
  - server/src/services/webhookSender.ts (new webhook sender service)
  - server/src/index.ts (imported and registered webhook sender on startup)
- **Learnings for future iterations:**
  - Use Node.js `crypto.createHmac('sha256', secret)` for HMAC-SHA256 signatures
  - AbortController with setTimeout for request timeouts in Node.js fetch
  - Check `error.name === 'AbortError'` to detect timeout vs network errors
  - WebhookConfig interface: { url: string, secret?: string, headers?: Record<string, string> }
  - Register senders at server startup to ensure they're available when feedback routes trigger

---

## 2026-01-12 - US-022
- What was implemented:
  - Webhook retry queue module in server/src/services/webhookRetryQueue.ts
  - In-memory queue using Map<string, RetryItem> (no external dependencies)
  - Exponential backoff delays: 1s, 4s, 16s (base 4: 4^0, 4^1, 4^2 seconds)
  - Maximum 3 retry attempts with automatic removal after final failure
  - Console logging for retry attempts and final failures
  - Queue processing runs every second when items are pending
  - Updated webhookSender.ts to queue failed deliveries (except config errors)
  - Internal sendWebhookRequest() function for retry queue (doesn't re-queue)
  - Retry queue initialized during registerWebhookSender() at server startup
- Files changed:
  - server/src/services/webhookRetryQueue.ts (new retry queue module)
  - server/src/services/webhookSender.ts (integrated retry queueing)
- **Learnings for future iterations:**
  - Separate internal send function from public send function when implementing retry logic
  - Use Map with unique IDs for in-memory queue management
  - setTimeout with recursive scheduling for periodic background tasks
  - ESLint rule: use `new Map<K, V>()` not `Map<K, V>: Map = new Map()` for generic constructors
  - Exponential backoff formula: base^attempt seconds (e.g., 4^0=1s, 4^1=4s, 4^2=16s)

---

## 2026-01-12 - US-023
- What was implemented:
  - POST /api/webhook/reply endpoint for developers to send replies to users
  - Validates API key via apiKeyAuth middleware (protected route)
  - Finds active conversation by session_id and api_key_id
  - Returns 404 if conversation not found for session_id
  - Stores outbound message in messages table with direction 'outbound'
  - Returns JSON with success status, message_id, and conversation_id
- Files changed:
  - server/src/routes/webhookReply.ts (new webhook reply route handler)
  - server/src/index.ts (imported and mounted webhookReplyRoutes under /api/webhook)
- **Learnings for future iterations:**
  - Webhook routes mounted under /api/webhook path (full path: POST /api/webhook/reply)
  - Outbound messages stored as plain text in content field (unlike inbound which uses JSON)
  - Use .returning() to get inserted record with auto-generated id for response

---

## 2026-01-12 - US-024
- What was implemented:
  - SSE endpoint at GET /api/events/:sessionId for real-time message delivery
  - SSE Manager service using Node.js EventEmitter for pub/sub pattern
  - Uses Hono's streamSSE() helper for Server-Sent Events streaming
  - Connection event sent when client connects
  - Heartbeat event every 30 seconds to keep connection alive
  - Message event when outbound messages created (via webhookReply route)
  - Graceful disconnect handling with stream.onAbort() callback
  - Route mounted without API key auth (widget connects by session ID)
- Files changed:
  - server/src/services/sseManager.ts (new SSE manager with EventEmitter pub/sub)
  - server/src/routes/events.ts (new SSE endpoint route)
  - server/src/routes/webhookReply.ts (emit SSE event after storing outbound message)
  - server/src/index.ts (imported and mounted events routes)
- **Learnings for future iterations:**
  - Use Hono's streamSSE() from 'hono/streaming' for SSE endpoints
  - EventEmitter with session-based event names (message:{sessionId}) for targeted delivery
  - stream.onAbort() returns a Promise that resolves when client disconnects
  - SSE routes should be mounted outside API key protected routes (widget has no API key)
  - Set EventEmitter.setMaxListeners(1000) for many concurrent connections
  - SSE data must be JSON.stringify()'d for complex objects

---

## 2026-01-12 - US-025: Widget SSE connection for replies
- What was implemented:
  - SSE client service (widget/src/services/sseClient.ts) using native EventSource API
  - MessageDisplay component for showing developer replies with 'Developer' label and timestamp
  - Notification badge on FloatingButton with unread count, animated pop effect
  - SSE integration in widget.ts - connects after first feedback submitted
  - Badge clears when panel opens, increments when replies arrive while panel is closed
  - Automatic reconnection with exponential backoff (1s base, 30s max, 10 attempts)
  - Updated test page (index.html) to demonstrate SSE functionality with logging
- Files changed:
  - widget/src/services/sseClient.ts (new SSE client with EventSource and reconnection)
  - widget/src/components/MessageDisplay.ts (new component for developer messages)
  - widget/src/components/FloatingButton.ts (added badge support with showBadge/hideBadge)
  - widget/src/index.ts (exported new components and SSE service)
  - widget/src/widget.ts (integrated SSE client and message display)
  - widget/index.html (updated test page to use SSE)
- **Learnings for future iterations:**
  - EventSource API handles reconnection automatically but we added manual control for better UX
  - Badge element should be positioned absolute relative to button container
  - MessageDisplay uses aria-live="polite" for screen reader accessibility
  - When panel reopens, MessageDisplay is recreated fresh (history preserved in US-026)
  - Test SSE messages via: curl -X POST http://localhost:3000/api/webhook/reply -H "Content-Type: application/json" -H "X-API-Key: test-api-key-12345" -d '{"session_id": "sess_xxx", "message": "test"}'

---

## 2026-01-13 - US-026: Conversation history in widget
- What was implemented:
  - ConversationHistory component (widget/src/components/ConversationHistory.ts) with full history display
  - User messages styled right-aligned with purple background
  - Developer messages styled left-aligned with gray background
  - Timestamps shown on each message with localized formatting
  - Scrollable message area with smooth scroll behavior
  - SessionStorage persistence using session ID as key
  - Auto-restore history when panel reopens
  - FeedbackForm callback updated to include submitted text and screenshot URL
  - Widget.ts integrated to add user messages to history after successful submission
  - Test page (index.html) updated to use new ConversationHistory component
- Files changed:
  - widget/src/components/ConversationHistory.ts (new conversation history component)
  - widget/src/components/FeedbackForm.ts (updated onSuccess callback signature)
  - widget/src/services/submitFeedback.ts (pass screenshot URL to onSuccess)
  - widget/src/widget.ts (replaced MessageDisplay with ConversationHistory)
  - widget/src/index.ts (exported new component and types)
  - widget/index.html (updated test page with new component)
- **Learnings for future iterations:**
  - Use sessionStorage with unique key per session (STORAGE_KEY_PREFIX + sessionId)
  - HistoryMessage type includes: id, direction ('user'|'developer'), text, timestamp, screenshotUrl
  - Messages are rendered chronologically with oldest first
  - Style user messages with align-self: flex-end, developer with flex-start
  - generateMessageId() creates unique IDs: msg_{timestamp}_{random}
  - Developer messages use server messageId for deduplication (dev_{messageId})
  - Container uses :empty pseudo-class to hide when no messages
  - FeedbackForm onSuccess callback now: (conversationId, submittedText, screenshotUrl?) => void

---

## 2026-01-13 - US-027: User follow-up replies
- What was implemented:
  - POST /api/reply endpoint (server/src/routes/reply.ts) for user follow-up messages
  - submitReply service (widget/src/services/submitReply.ts) for widget-side reply submission
  - FeedbackForm updated to support reply mode with different UI
  - Placeholder changes from "What's on your mind?" to "Type your reply..."
  - Button text changes from "Send Feedback" to "Send Reply"
  - Screenshot button hidden in reply mode (not typically needed for quick replies)
  - Voice input still available in reply mode
  - Conversation ID persistence via ConversationHistory component (sessionStorage)
  - Widget.ts restores conversation ID from storage when panel reopens
  - FeedbackForm.setReplyMode() method to switch to reply mode after first feedback
  - Replies added to conversation history and persisted
- Files changed:
  - server/src/routes/reply.ts (new reply endpoint)
  - server/src/index.ts (mounted /api/reply route)
  - widget/src/services/submitReply.ts (new reply submission service)
  - widget/src/components/FeedbackForm.ts (reply mode support)
  - widget/src/components/ConversationHistory.ts (conversation ID storage)
  - widget/src/widget.ts (conversation ID restoration and reply handling)
  - widget/src/index.ts (exported new service and types)
  - widget/widget-test.html (updated test API key)
- **Learnings for future iterations:**
  - Conversation ID must be persisted to sessionStorage for panel close/reopen scenarios
  - ConversationHistory.getConversationId() and setConversationId() for persistence
  - Reply endpoint validates conversation_id, text, and session_id
  - FeedbackForm exposes isReplyMode() and setReplyMode(id) for mode control
  - Reply mode: isInReplyMode() closure function checks if currentConversationId is set
  - onReplySuccess callback notifies parent when reply succeeds (vs onSuccess for initial feedback)

---

## 2026-01-13 - US-028: Dashboard project setup
- What was implemented:
  - React app in /dashboard with Vite build tooling
  - TailwindCSS configuration with PostCSS (tailwind.config.js, postcss.config.js)
  - React Router with BrowserRouter and routes: /, /login, /setup
  - Layout component with header, HeyDev logo, navigation, and outlet for child routes
  - HomePage with welcome message and call-to-action buttons
  - LoginPage with email input form for magic link (placeholder)
  - SetupPage with API key and notification channels sections (placeholder)
  - Vite config with React plugin and dev server on port 5174
- Files changed:
  - dashboard/package.json (added tailwindcss, postcss, autoprefixer, react-router-dom)
  - dashboard/index.html (new HTML entry point)
  - dashboard/vite.config.ts (new Vite config with React plugin)
  - dashboard/tailwind.config.js (new Tailwind config)
  - dashboard/postcss.config.js (new PostCSS config)
  - dashboard/src/main.tsx (React entry point with BrowserRouter)
  - dashboard/src/App.tsx (Routes configuration)
  - dashboard/src/index.css (Tailwind directives)
  - dashboard/src/components/Layout.tsx (Header + Outlet layout)
  - dashboard/src/pages/HomePage.tsx (Landing page)
  - dashboard/src/pages/LoginPage.tsx (Magic link login form)
  - dashboard/src/pages/SetupPage.tsx (Setup configuration page)
- **Learnings for future iterations:**
  - Dashboard runs on port 5174 (different from widget's 5173 and server's 3000)
  - Use `npm run dev` in dashboard/ to start dev server
  - Layout uses React Router's Outlet component for nested routes
  - TailwindCSS configured for .tsx files in content array
  - Dashboard components are functional React components (not factory pattern like widget)

---

## 2026-01-13 - US-029: Dashboard magic link authentication
- What was implemented:
  - Users, auth_tokens, and sessions tables in database schema
  - POST /api/auth/magic-link endpoint sends magic link email (15-minute expiry)
  - GET /api/auth/verify validates token, creates 7-day session, sets httpOnly cookie
  - GET /api/auth/me returns authenticated user info
  - POST /api/auth/logout clears session
  - Email service with Resend API integration (console fallback in dev)
  - LoginPage with form submission, loading states, success/error messages
  - LoginPage handles error query params from failed verifications
  - SetupPage requires authentication, shows user email, has sign out button
  - Vite client types added to dashboard tsconfig
- Files changed:
  - server/src/db/schema.ts (added users, authTokens, sessions tables)
  - server/drizzle/0001_faulty_vanisher.sql (migration for new tables)
  - server/src/services/emailService.ts (new email service with magic link template)
  - server/src/routes/auth.ts (magic-link, verify, me, logout endpoints)
  - server/src/index.ts (mounted auth routes)
  - dashboard/src/pages/LoginPage.tsx (full implementation with states)
  - dashboard/src/pages/SetupPage.tsx (auth check and user display)
  - dashboard/tsconfig.json (added vite/client types)
- **Learnings for future iterations:**
  - Use Hono's setCookie/getCookie from 'hono/cookie' for session management
  - httpOnly cookies with sameSite: 'Lax' for CSRF protection
  - Dashboard fetches must use credentials: 'include' for cookies to work
  - Magic link tokens are one-time use (usedAt column tracks this)
  - Email service detects RESEND_API_KEY env var to switch from console to real emails
  - Redirect from verify endpoint goes directly to dashboard URL (cross-origin)

---

## 2026-01-13 - US-030: Dashboard API key generation
- What was implemented:
  - API key management routes (GET, POST, DELETE /api/keys)
  - Session-based authentication via getAuthenticatedUser helper
  - API key format: hd_live_{32 hex chars} for easy identification
  - Key prefix display (first 12 chars + ****) for subsequent views
  - Setup page shows Generate API Key button when no key exists
  - On generation: warning banner, full key with copy button, script snippet
  - On refresh: Active badge, key prefix, placeholder snippet
- Files changed:
  - server/src/routes/keys.ts (new API key management routes)
  - server/src/index.ts (mounted keys routes)
  - dashboard/src/pages/SetupPage.tsx (API key generation UI)
- **Learnings for future iterations:**
  - API keys stored plain for validation but only prefix returned via GET
  - Use getCookie from 'hono/cookie' for session-based auth in routes
  - generateApiKey() uses crypto.randomBytes(16).toString('hex')
  - getKeyPrefix() returns first 12 chars + '****' for display
  - Setup page uses separate states for apiKeyInfo (existing) vs generatedKey (just created)
  - Copy buttons use navigator.clipboard with fallback to document.execCommand

---

## 2026-01-13 - US-031: Dashboard notification channel list
- What was implemented:
  - Channel management API routes (GET, POST, PATCH /api/channels)
  - GET /api/channels returns all four channel types with status
  - PATCH /api/channels/:type/toggle enables/disables a channel
  - Channel cards UI for Slack, Email, SMS, Webhook in SetupPage
  - Each card displays: icon, name, description, status badge, Configure button, toggle switch
  - Status badges: "Connected" (green), "Pending" (yellow), "Not configured" (gray)
  - Icon color changes based on enabled state (indigo when enabled, gray when disabled)
  - Toggle switches with accessible switch role and aria-checked/aria-label
  - Configure button shows placeholder alert (implemented in US-032/033)
- Files changed:
  - server/src/routes/channels.ts (new channel management routes)
  - server/src/index.ts (mounted channels routes)
  - dashboard/src/pages/SetupPage.tsx (channel cards UI with icons, toggles, badges)
- **Learnings for future iterations:**
  - Channel routes use same getAuthenticatedUser pattern as keys routes
  - channelTypes array from schema used for iteration and validation
  - Toggle state stored in channels table with apiKeyId foreign key
  - CHANNEL_META object maps channel types to display properties (icon, name, description)
  - React switch pattern: role="switch" aria-checked={enabled} with translate-x animation
  - API key required before channels can be configured (guard in UI)

---

## 2026-01-13 - US-032: Dashboard webhook channel configuration
- What was implemented:
  - WebhookConfigModal component (dashboard/src/components/WebhookConfigModal.tsx)
  - URL input field with validation
  - Signing secret input with Generate button
  - Custom headers key-value editor with add/remove functionality
  - Test Webhook button with loading state and success/failure display
  - Save Configuration button persists to database
  - GET /api/channels/webhook/secret endpoint generates 'whsec_' prefixed secrets
  - POST /api/channels/webhook/test endpoint sends test payload with HMAC signature
  - SetupPage integration: opens modal on webhook Configure click
  - Channel status updates to "Connected" after successful save
- Files changed:
  - dashboard/src/components/WebhookConfigModal.tsx (new modal component)
  - dashboard/src/pages/SetupPage.tsx (modal integration, save handler)
  - server/src/routes/channels.ts (webhook/secret and webhook/test endpoints)
- **Learnings for future iterations:**
  - Use crypto.randomBytes(24).toString('hex') for 48-char secret generation
  - Webhook secrets use 'whsec_' prefix convention (similar to Stripe)
  - Modal components receive isOpen, onClose, onSave, and initialConfig props
  - Form reset on modal open using useEffect with isOpen dependency
  - Convert headers object to array for dynamic key-value editor
  - Test endpoint doesn't require API key auth but does validate session
  - Route ordering matters: specific routes (/webhook/secret, /webhook/test) before generic (/:type)

---

## 2026-01-13 - US-033: Dashboard email channel configuration
- What was implemented:
  - EmailConfigModal component (dashboard/src/components/EmailConfigModal.tsx)
  - Email address input with validation
  - Send verification button triggers POST /api/channels/email/send-verification
  - Verification email with 6-digit code using sendEmailVerificationCode service
  - Code input field with 6-digit restriction
  - POST /api/channels/email/verify endpoint validates code and saves channel
  - Multi-step modal UI: email input → verification code → verified state
  - "Change email" and "Resend code" functionality
  - SetupPage integration opens modal on Email Configure click
  - Channel status updates to "Connected" after successful verification
- Files changed:
  - dashboard/src/components/EmailConfigModal.tsx (new modal component)
  - dashboard/src/pages/SetupPage.tsx (modal integration, email config state)
  - server/src/routes/channels.ts (email/send-verification and email/verify endpoints)
  - server/src/services/emailService.ts (sendEmailVerificationCode function)
- **Learnings for future iterations:**
  - Use in-memory Map for short-lived verification codes (emailVerificationCodes)
  - Verification codes are 6 digits generated with Math.floor(100000 + Math.random() * 900000)
  - Codes expire after 10 minutes (configurable)
  - Route ordering: /email/send-verification and /email/verify must come before /:type
  - Multi-step modal pattern: use step state ('email' | 'verify' | 'verified')
  - Input restriction for digits only: e.target.value.replace(/\D/g, '').slice(0, 6)
  - EmailConfig interface: { email: string, verified?: boolean }

---

## 2026-01-13 - US-034: Email notification sender
- What was implemented:
  - Email notification sender service (server/src/services/emailNotificationSender.ts)
  - HTML email template with feedback text, screenshot, context table
  - Plain text fallback for email clients without HTML support
  - Subject line: 'New feedback from [page path]' using URL parsing
  - Console errors section in email with red styling
  - Validates email is configured and verified before sending
  - Escapes HTML in user content to prevent XSS
  - Registers with channelRouter using registerEmailSender()
  - Uses existing Resend integration from emailService.ts
- Files changed:
  - server/src/services/emailNotificationSender.ts (new email notification sender)
  - server/src/index.ts (imported and registered email sender on startup)
- **Learnings for future iterations:**
  - Email notification senders follow same pattern as webhookSender.ts
  - Use registerChannelSender() from channelRouter to register channel-specific senders
  - EmailConfig interface matches what dashboard saves: { email: string, verified?: boolean }
  - escapeHtml() function needed to prevent XSS in email content from user feedback
  - getPagePath() extracts path from URL for cleaner subject line (not full URL)
  - Plain text fallback is important for email accessibility

---

## 2026-01-13 - US-035: Docker Compose for self-hosting
- What was implemented:
  - Dockerfile with multi-stage build (builder + production stages)
  - Uses Node 20 Alpine for smaller image size
  - Installs better-sqlite3 build dependencies (python3, make, g++)
  - docker-compose.yml with server service configuration
  - Named volumes for data persistence: heydev-data, heydev-uploads
  - .env.example with documented environment variables
  - README.md with full self-hosting guide, API reference, and data backup instructions
  - .dockerignore to optimize Docker build context
  - Health check configured in both Dockerfile and docker-compose.yml
- Files changed:
  - Dockerfile (new multi-stage Docker build)
  - docker-compose.yml (new Docker Compose configuration)
  - .env.example (new environment variables template)
  - README.md (new project documentation)
  - .dockerignore (new Docker ignore rules)
- **Learnings for future iterations:**
  - better-sqlite3 requires native dependencies: apk add python3 make g++
  - Multi-stage builds: use "AS builder" for build stage, copy only dist to production
  - Named volumes persist data across container recreation: heydev-data:/app/server/data
  - Docker health checks use wget (more portable than curl in Alpine)
  - npm ci --workspace=server --omit=dev for production dependencies only
  - WORKDIR /app/server before CMD to run from correct directory

---

## 2026-01-13 - US-036: Widget dark mode support
- What was implemented:
  - Theme utility module (widget/src/utils/theme.ts) with light/dark color definitions
  - 20 CSS custom properties defined for dark theme colors
  - prefers-color-scheme media query detection for automatic theme selection
  - data-theme attribute support on script tag ('light', 'dark', 'auto')
  - getAutoThemeCSS() generates responsive CSS with @media query
  - getThemeCSS() generates static CSS for explicit theme
  - createThemeStyleElement() creates style element for Shadow DOM injection
  - watchSystemTheme() utility for reacting to system theme changes
  - Updated test page (index.html) with theme toggle buttons
  - SHADOW_RESET_STYLES updated to use --heydev-text CSS variable
- Files changed:
  - widget/src/utils/theme.ts (new theme utility module)
  - widget/src/widget.ts (theme integration in Shadow DOM)
  - widget/src/index.ts (export theme utilities)
  - widget/index.html (theme toggle controls for testing)
- **Learnings for future iterations:**
  - Theme CSS variables should be injected BEFORE component styles in Shadow DOM
  - Use :host selector for CSS custom property definitions in Shadow DOM
  - @media (prefers-color-scheme: dark) works inside Shadow DOM
  - data-theme attribute on script tag allows host page to control widget theme
  - Dark theme colors: lighter primary (#818cf8), dark backgrounds (#1f2937, #111827)
  - Success/error colors need inverted contrast in dark mode

---

## 2026-01-13 - US-037: Widget accessibility
- What was implemented:
  - Accessibility utility module (widget/src/utils/accessibility.ts)
  - createFocusTrap() function for trapping focus within containers
  - getFocusableElements() helper to query focusable elements in DOM
  - announceToScreenReader() for screen reader announcements
  - prefersReducedMotion() for checking user motion preferences
  - Updated FeedbackPanel to use focus trap when open
  - Escape key closes panel (handled by focus trap)
  - Focus returns to trigger element when panel closes
  - All ARIA labels were already present from previous stories
  - prefers-reduced-motion already respected via CSS media queries
- Files changed:
  - widget/src/utils/accessibility.ts (new accessibility utility module)
  - widget/src/components/FeedbackPanel.ts (integrated focus trap)
  - widget/src/index.ts (exported accessibility utilities)
- **Learnings for future iterations:**
  - Focus trap captures Tab/Shift+Tab and cycles within container
  - Use capture phase (true) for event listeners to catch before propagation
  - requestAnimationFrame ensures element is focusable before focus()
  - Shadow DOM focus requires checking shadowRoot.activeElement
  - Focus trap should handle onEscape callback for panel close
  - Store previouslyFocusedElement to restore focus when trap deactivates
  - FOCUSABLE_SELECTOR: button:not([disabled]), [href], input:not([disabled]), etc.

---
